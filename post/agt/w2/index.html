<!DOCTYPE html>

<html lang="it">
 
  <head>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.64.1" />
  <meta name="theme" content="a random mix of bootstrap, lanyon-hugo and hugo-academic themes">
  <meta name="author" content="DL Ferrario">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> 
      AGT: W2 &middot; DL Ferrario&#39;s Test  Web Page
     </title>

  
  <link rel="stylesheet" href="//www.dlfer.xyz//css/highlight.min.css">  
  <script src="//www.dlfer.xyz//js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  <link rel="stylesheet" href="//www.dlfer.xyz//css/bootstrap.min.css">
  <link rel="stylesheet" href="//www.dlfer.xyz//css/font-awesome.min.css">
  <link rel="stylesheet" href="//www.dlfer.xyz//css/academicons.min.css">
  <link rel="stylesheet" href="//www.dlfer.xyz//css/otherstyle.css">
  <link rel="stylesheet" href="//www.dlfer.xyz//css/poole.css">
  <link rel="stylesheet" href="//www.dlfer.xyz//css/syntax.css">
  <link rel="stylesheet" href="//www.dlfer.xyz//css/lanyon.css">
  
  <link rel="stylesheet" href="//www.dlfer.xyz//css/fonts.css">
  
   
  <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:300|Merriweather|Roboto+Mono" rel="stylesheet">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="//www.dlfer.xyz/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="//www.dlfer.xyz/assets/favicon-gears.ico">
</head>

  <body class="theme-base-0x">
    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="//www.dlfer.xyz/">Home</a>
    <a class="sidebar-nav-item " href="//www.dlfer.xyz/post">All Posts</a>
    <a class="sidebar-nav-item " href="//www.dlfer.xyz/topics/">Topics</a>
    <a class="sidebar-nav-item " href="//www.dlfer.xyz/tags/">Tags</a>
    
    
      
        <a class="sidebar-nav-item " href="//www.dlfer.xyz/p/papers/">Publications</a>
      
    
      
        <a class="sidebar-nav-item " href="//www.dlfer.xyz/p/now/">About/now</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </nav>
</div>

<title>
    
      AGT: W2 &middot; DL Ferrario&#39;s Test  Web Page
    
  </title>
    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="//www.dlfer.xyz/" title="Home">DL Ferrario&#39;s Test  Web Page</a>
     
          </h3>
        </div>
      </div>
      <div class="container content">


<div class="post">
  <h1 class="post-title">AGT: W2</h1>
  <span class="post-date">2020-11-24 
	  
	  (<i class="fa fa-refresh" aria-hidden="true"></i>&nbsp;2020-11-24) 
	  
  </span>
  <h2 id="dato-da-fare-la-scorsa-volta">Dato da fare la scorsa volta:</h2>
<blockquote>
<p>Scrivere un notebook python/sagemath (dopo averlo correttamente installato?) che dato un grafo (assegnato come complesso simpliciale astratto) calcola i due gruppi di omologia <span class="math inline">\(H_0\)</span> e <span class="math inline">\(H_1\)</span>. Opzionale: assegnare (in qualche modo razionale) delle coordinate ai vertici, trasformandolo in grafo <strong>possibilmente</strong> euclideo, e visualizzare quel che viene.</p>
</blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># define a function for visualization:</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">import</span> matplotlib <span class="im">as</span> mpl</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="im">from</span> matplotlib.collections <span class="im">import</span> LineCollection</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb1-6" title="6">mpl.rcParams[<span class="st">&#39;figure.figsize&#39;</span>] <span class="op">=</span> (<span class="fl">8.0</span>, <span class="fl">8.0</span>)</a>
<a class="sourceLine" id="cb1-7" title="7">pi<span class="op">=</span>np.pi</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">def</span> view(X,show_labels<span class="op">=</span><span class="va">False</span>):</a>
<a class="sourceLine" id="cb1-9" title="9">    vertices,edges<span class="op">=</span>X <span class="co"># assign names...</span></a>
<a class="sourceLine" id="cb1-10" title="10">    fig<span class="op">=</span>plt.figure()</a>
<a class="sourceLine" id="cb1-11" title="11">    ax<span class="op">=</span>fig.gca()</a>
<a class="sourceLine" id="cb1-12" title="12">    ax.set_aspect(<span class="st">&#39;equal&#39;</span>)</a>
<a class="sourceLine" id="cb1-13" title="13">    ax.set_axis_off()</a>
<a class="sourceLine" id="cb1-14" title="14">    fig.set_facecolor(<span class="st">&#39;white&#39;</span>)</a>
<a class="sourceLine" id="cb1-15" title="15">    </a>
<a class="sourceLine" id="cb1-16" title="16">    lc <span class="op">=</span> LineCollection(edges, color<span class="op">=</span><span class="st">&quot;black&quot;</span>, lw<span class="op">=</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-17" title="17">    </a>
<a class="sourceLine" id="cb1-18" title="18">    ax.add_collection(lc)</a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="cf">for</span> P <span class="kw">in</span> vertices:</a>
<a class="sourceLine" id="cb1-20" title="20">        ax.add_patch(plt.Circle(P, <span class="fl">0.005</span><span class="op">*</span>N<span class="op">/</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">&#39;black&#39;</span>,</a>
<a class="sourceLine" id="cb1-21" title="21">                        linewidth<span class="op">=</span><span class="dv">2</span>, rasterized<span class="op">=</span><span class="va">False</span>, antialiased<span class="op">=</span><span class="va">True</span>,facecolor<span class="op">=</span><span class="st">&#39;w&#39;</span>,</a>
<a class="sourceLine" id="cb1-22" title="22">                        zorder<span class="op">=</span><span class="dv">1000</span>) )</a>
<a class="sourceLine" id="cb1-23" title="23">        </a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="cf">if</span> show_labels:</a>
<a class="sourceLine" id="cb1-25" title="25">          <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(vertices)):</a>
<a class="sourceLine" id="cb1-26" title="26">                Px,Py<span class="op">=</span>vertices[j]</a>
<a class="sourceLine" id="cb1-27" title="27">                ax.annotate(<span class="st">&quot;$</span><span class="sc">%s</span><span class="st">$&quot;</span> <span class="op">%</span> j, vertices[j] , (Px<span class="fl">-0.06</span>,Py<span class="fl">+0.01</span>),fontsize<span class="op">=</span><span class="dv">24</span>, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>)</a>
<a class="sourceLine" id="cb1-28" title="28">    ax.plot()   <span class="co">#Causes an autoscale update.</span></a>
<a class="sourceLine" id="cb1-29" title="29">    plt.show()</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="co"># Primo problema: come **codificare** un grafo: elenco di vertici (euclidei?) e di spigoli.</span></a>
<a class="sourceLine" id="cb2-2" title="2">N<span class="op">=</span><span class="dv">3</span> <span class="co">#numero di case/pozzi</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="im">import</span> random</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">A<span class="op">=</span>[(random.random(),random.random()) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(N)]  <span class="co"># complesso simplicial astratto o euclideo</span></a>
<a class="sourceLine" id="cb2-6" title="6">B<span class="op">=</span>[ (random.random(), random.random()) <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(N)]  <span class="co"># (niente cooordinate o coordinate?)</span></a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">vertices <span class="op">=</span> A <span class="op">+</span> B <span class="co"># concatenation of lists (overloading degli operatori)</span></a>
<a class="sourceLine" id="cb2-9" title="9">edges <span class="op">=</span> [ [x, y] <span class="cf">for</span> x <span class="kw">in</span> A <span class="cf">for</span> y <span class="kw">in</span> B[<span class="dv">1</span>:] ] <span class="co"># math notation</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co"># un grafo quindi è la coppia:</span></a>
<a class="sourceLine" id="cb2-11" title="11">X <span class="op">=</span> (vertices,edges) <span class="co"># come complesso simpliciale mancherebbero gli 0-simplessi, però...</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co"># proviamo a scrivere una funzione per calcolare l&#39;omologia: h_0 e h_1: prima </span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co"># di tutto dovremmo capire se è connesso oppure no... </span></a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16"></a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">view(X,show_labels<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<figure>
<img src="w2_files/w2_4_0.png" alt="png" /><figcaption>png</figcaption>
</figure>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># now: come calcolare le componenti connesse? e l&#39;omologia? come fare? </span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"># Classico: https://en.wikipedia.org/wiki/Breadth-first_search</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="im">from</span> scipy.sparse <span class="im">import</span> csr_matrix</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="im">from</span> scipy.sparse.csgraph <span class="im">import</span> connected_components</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co"># quindi: h_0 è il numero delle componenti connesse:</span></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">def</span> h0(X):</a>
<a class="sourceLine" id="cb4-10" title="10">    vertices,edges <span class="op">=</span> X </a>
<a class="sourceLine" id="cb4-11" title="11">    incidence_matrix <span class="op">=</span> np.zeros((<span class="bu">len</span>(vertices),<span class="bu">len</span>(vertices)))</a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="cf">for</span> s <span class="kw">in</span> edges:</a>
<a class="sourceLine" id="cb4-13" title="13">        x<span class="op">=</span>vertices.index(s[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb4-14" title="14">        y<span class="op">=</span>vertices.index(s[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb4-15" title="15">    </a>
<a class="sourceLine" id="cb4-16" title="16">        incidence_matrix[x,y] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-17" title="17">        incidence_matrix[y,x] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-18" title="18">    graph <span class="op">=</span> csr_matrix(incidence_matrix)</a>
<a class="sourceLine" id="cb4-19" title="19">    n_components <span class="op">=</span> connected_components(csgraph<span class="op">=</span>graph, directed<span class="op">=</span><span class="va">False</span>, return_labels<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb4-20" title="20">    <span class="cf">return</span> n_components</a>
<a class="sourceLine" id="cb4-21" title="21"></a>
<a class="sourceLine" id="cb4-22" title="22"><span class="bu">print</span>(h0(X))</a>
<a class="sourceLine" id="cb4-23" title="23">    </a></code></pre></div>
<pre><code>2</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="co"># ora calcoliamo h_1: teniamo conto che h_0 - h_1 = c_0 - c_1 :</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co"># segue che h_1 = h0 - c_0 + c_1 </span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">def</span> h1(X):</a>
<a class="sourceLine" id="cb6-4" title="4">    vertices, edges <span class="op">=</span> X </a>
<a class="sourceLine" id="cb6-5" title="5">    c0 <span class="op">=</span> <span class="bu">len</span>(vertices)</a>
<a class="sourceLine" id="cb6-6" title="6">    c1 <span class="op">=</span> <span class="bu">len</span>(edges)</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="cf">return</span> h0(X) <span class="op">-</span> c0 <span class="op">+</span> c1</a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="bu">print</span>(h1(X))</a></code></pre></div>
<pre><code>2</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="co"># e per dare delle coordinate migliori di quelle random?</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="im">import</span> scipy.optimize</a>
<a class="sourceLine" id="cb8-3" title="3">elastic_constant<span class="op">=</span><span class="fl">1.0</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">def</span> sq_euc_norm(P):</a>
<a class="sourceLine" id="cb8-6" title="6">    result<span class="op">=</span><span class="fl">0.0</span></a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(P)):</a>
<a class="sourceLine" id="cb8-8" title="8">        result <span class="op">+=</span> P[j] <span class="op">*</span> P[j]</a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="kw">def</span> euc_norm(P):</a>
<a class="sourceLine" id="cb8-12" title="12">    sq_result <span class="op">=</span> sq_euc_norm(P)</a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="cf">return</span> sq_result <span class="op">**</span> (<span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb8-14" title="14"></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="kw">def</span> distance(P, Q):</a>
<a class="sourceLine" id="cb8-16" title="16">    result <span class="op">=</span> euc_norm(P<span class="op">-</span>Q)</a>
<a class="sourceLine" id="cb8-17" title="17">    <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb8-18" title="18"></a>
<a class="sourceLine" id="cb8-19" title="19"><span class="kw">def</span> vector_product(P,Q):</a>
<a class="sourceLine" id="cb8-20" title="20">    vector_product<span class="op">=</span>np.zeros(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb8-21" title="21">    vector_product[<span class="dv">0</span>] <span class="op">=</span> P[<span class="dv">1</span>] <span class="op">*</span> Q[<span class="dv">2</span>] <span class="op">-</span> Q[<span class="dv">1</span>] <span class="op">*</span> P[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb8-22" title="22">    vector_product[<span class="dv">1</span>] <span class="op">=</span> Q[<span class="dv">0</span>] <span class="op">*</span> P[<span class="dv">2</span>] <span class="op">-</span> P[<span class="dv">0</span>] <span class="op">*</span> Q[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb8-23" title="23">    vector_product[<span class="dv">2</span>] <span class="op">=</span> P[<span class="dv">0</span>] <span class="op">*</span> Q[<span class="dv">1</span>] <span class="op">-</span> Q[<span class="dv">0</span>] <span class="op">*</span> P[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-24" title="24">    <span class="cf">return</span> vector_product</a>
<a class="sourceLine" id="cb8-25" title="25"></a>
<a class="sourceLine" id="cb8-26" title="26"><span class="kw">def</span> dot_product(P,Q):</a>
<a class="sourceLine" id="cb8-27" title="27">    <span class="cf">return</span> np.dot(P,Q)</a>
<a class="sourceLine" id="cb8-28" title="28"></a>
<a class="sourceLine" id="cb8-29" title="29"><span class="kw">def</span> Uij(P,Q,are_endpoints<span class="op">=</span><span class="va">False</span>):</a>
<a class="sourceLine" id="cb8-30" title="30">    <span class="co">&quot;&quot;&quot;interaction of P and Q: edges elastic attract, all repulsive&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-31" title="31">    <span class="cf">if</span> are_endpoints:</a>
<a class="sourceLine" id="cb8-32" title="32">        <span class="cf">return</span> elastic_constant <span class="op">*</span> sq_euc_norm(P<span class="op">-</span>Q) <span class="op">+</span> <span class="fl">1.</span> <span class="op">/</span> euc_norm(P<span class="op">-</span>Q)</a>
<a class="sourceLine" id="cb8-33" title="33">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb8-34" title="34">        <span class="cf">return</span> <span class="fl">1.</span> <span class="op">/</span> euc_norm(P<span class="op">-</span>Q)</a>
<a class="sourceLine" id="cb8-35" title="35"></a>
<a class="sourceLine" id="cb8-36" title="36"><span class="kw">def</span> grad_Uij(P,Q,are_endpoints<span class="op">=</span><span class="va">False</span>):</a>
<a class="sourceLine" id="cb8-37" title="37">    <span class="co">&quot;&quot;&quot;grad of interaction of P and Q, wrt P&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-38" title="38">    <span class="cf">if</span> are_endpoints:</a>
<a class="sourceLine" id="cb8-39" title="39">        <span class="cf">return</span> <span class="fl">2.0</span> <span class="op">*</span> elastic_constant <span class="op">*</span> (P<span class="op">-</span>Q) <span class="op">-</span> (P<span class="op">-</span>Q) <span class="op">*</span> euc_norm(P<span class="op">-</span>Q)<span class="op">**</span>(<span class="op">-</span><span class="fl">3.</span>)</a>
<a class="sourceLine" id="cb8-40" title="40">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb8-41" title="41">        <span class="cf">return</span> <span class="op">-</span> (P<span class="op">-</span>Q) <span class="op">*</span> euc_norm(P<span class="op">-</span>Q)<span class="op">**</span>(<span class="op">-</span><span class="fl">3.</span>)</a>
<a class="sourceLine" id="cb8-42" title="42"></a>
<a class="sourceLine" id="cb8-43" title="43"><span class="kw">def</span> potential(conf,is_edge):</a>
<a class="sourceLine" id="cb8-44" title="44">    energy <span class="op">=</span> <span class="fl">0.0</span></a>
<a class="sourceLine" id="cb8-45" title="45">    number_of_vertices,eucl_dim<span class="op">=</span>conf.shape</a>
<a class="sourceLine" id="cb8-46" title="46">    <span class="co"># numba.prange requires parallel=True flag to compile.</span></a>
<a class="sourceLine" id="cb8-47" title="47">    <span class="co"># It causes the loop to run in parallel in multiple threads.</span></a>
<a class="sourceLine" id="cb8-48" title="48">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(number_of_vertices<span class="dv">-1</span>):</a>
<a class="sourceLine" id="cb8-49" title="49">        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, number_of_vertices ):</a>
<a class="sourceLine" id="cb8-50" title="50">            <span class="cf">if</span> is_edge[i,j]:</a>
<a class="sourceLine" id="cb8-51" title="51">                energy <span class="op">+=</span> Uij( conf[i,:],conf[j,:], are_endpoints<span class="op">=</span><span class="va">True</span> )</a>
<a class="sourceLine" id="cb8-52" title="52">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb8-53" title="53">                energy <span class="op">+=</span> Uij( conf[i,:],conf[j,:], are_endpoints<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb8-54" title="54">    <span class="cf">return</span> energy</a>
<a class="sourceLine" id="cb8-55" title="55"></a>
<a class="sourceLine" id="cb8-56" title="56"><span class="kw">def</span> grad_potential(conf,is_edge):</a>
<a class="sourceLine" id="cb8-57" title="57">    number_of_vertices,eucl_dim<span class="op">=</span>conf.shape</a>
<a class="sourceLine" id="cb8-58" title="58">    grad <span class="op">=</span> np.zeros((number_of_vertices,eucl_dim))</a>
<a class="sourceLine" id="cb8-59" title="59">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(number_of_vertices<span class="dv">-1</span>):</a>
<a class="sourceLine" id="cb8-60" title="60">        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, number_of_vertices ):</a>
<a class="sourceLine" id="cb8-61" title="61">            <span class="cf">if</span> is_edge[i,j]:</a>
<a class="sourceLine" id="cb8-62" title="62">                grad[i,:] <span class="op">+=</span> grad_Uij( conf[i,:],conf[j,:], are_endpoints<span class="op">=</span><span class="va">True</span> )</a>
<a class="sourceLine" id="cb8-63" title="63">                grad[j,:] <span class="op">+=</span> grad_Uij( conf[j,:],conf[i,:], are_endpoints<span class="op">=</span><span class="va">True</span> )</a>
<a class="sourceLine" id="cb8-64" title="64">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb8-65" title="65">                grad[i,:] <span class="op">+=</span> grad_Uij( conf[i,:],conf[j,:], are_endpoints<span class="op">=</span><span class="va">False</span> )</a>
<a class="sourceLine" id="cb8-66" title="66">                grad[j,:] <span class="op">+=</span> grad_Uij( conf[j,:],conf[i,:], are_endpoints<span class="op">=</span><span class="va">False</span> )</a>
<a class="sourceLine" id="cb8-67" title="67">    <span class="cf">return</span> grad</a>
<a class="sourceLine" id="cb8-68" title="68"></a>
<a class="sourceLine" id="cb8-69" title="69"><span class="kw">def</span> euclidean_embedding(vertices,edges,dim<span class="op">=</span><span class="dv">2</span>):</a>
<a class="sourceLine" id="cb8-70" title="70">    number_of_vertices<span class="op">=</span><span class="bu">len</span>(vertices)</a>
<a class="sourceLine" id="cb8-71" title="71">    eucl_dim<span class="op">=</span>dim</a>
<a class="sourceLine" id="cb8-72" title="72"></a>
<a class="sourceLine" id="cb8-73" title="73">    is_edge<span class="op">=</span>np.zeros( (number_of_vertices,)<span class="op">*</span><span class="dv">2</span> , dtype<span class="op">=</span><span class="bu">bool</span>)</a>
<a class="sourceLine" id="cb8-74" title="74">    <span class="cf">for</span> (i,j) <span class="kw">in</span> edges:</a>
<a class="sourceLine" id="cb8-75" title="75">        is_edge[i,j]<span class="op">=</span><span class="va">True</span></a>
<a class="sourceLine" id="cb8-76" title="76"></a>
<a class="sourceLine" id="cb8-77" title="77">    <span class="kw">def</span> opt_fun(x):</a>
<a class="sourceLine" id="cb8-78" title="78">        conf<span class="op">=</span>x.reshape(number_of_vertices,eucl_dim)</a>
<a class="sourceLine" id="cb8-79" title="79">        result <span class="op">=</span> potential(conf,is_edge)</a>
<a class="sourceLine" id="cb8-80" title="80">        <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb8-81" title="81">    </a>
<a class="sourceLine" id="cb8-82" title="82">    <span class="kw">def</span> opt_jac(x):</a>
<a class="sourceLine" id="cb8-83" title="83">        conf<span class="op">=</span>x.reshape(number_of_vertices,eucl_dim)</a>
<a class="sourceLine" id="cb8-84" title="84">        result <span class="op">=</span> grad_potential(conf,is_edge)</a>
<a class="sourceLine" id="cb8-85" title="85">        <span class="cf">return</span> result.reshape(number_of_vertices<span class="op">*</span>eucl_dim)</a>
<a class="sourceLine" id="cb8-86" title="86">    X0<span class="op">=</span>np.random.rand( number_of_vertices,eucl_dim )</a>
<a class="sourceLine" id="cb8-87" title="87">    result <span class="op">=</span> scipy.optimize.minimize(opt_fun,X0,method<span class="op">=</span><span class="st">&#39;CG&#39;</span>,jac<span class="op">=</span>opt_jac)</a>
<a class="sourceLine" id="cb8-88" title="88">    </a>
<a class="sourceLine" id="cb8-89" title="89">    outconf<span class="op">=</span>result.x.reshape(number_of_vertices,eucl_dim)</a>
<a class="sourceLine" id="cb8-90" title="90">    howsol<span class="op">=</span>euc_norm(result.jac)</a>
<a class="sourceLine" id="cb8-91" title="91">    <span class="bu">print</span>(<span class="st">&quot;howsol: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(howsol))</a>
<a class="sourceLine" id="cb8-92" title="92">    <span class="co"># print(outconf)</span></a>
<a class="sourceLine" id="cb8-93" title="93">    eucl_vertices<span class="op">=</span> [ <span class="bu">tuple</span>( outconf[i,:] )  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(number_of_vertices) ]</a>
<a class="sourceLine" id="cb8-94" title="94">    eucl_edges<span class="op">=</span> [ (eucl_vertices[i],eucl_vertices[j]) <span class="cf">for</span> i,j <span class="kw">in</span> edges ]</a>
<a class="sourceLine" id="cb8-95" title="95">    <span class="cf">return</span> (eucl_vertices,eucl_edges)</a>
<a class="sourceLine" id="cb8-96" title="96"></a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">N<span class="op">=</span><span class="dv">5</span> <span class="co">#numero di case/pozzi</span></a>
<a class="sourceLine" id="cb9-2" title="2">A<span class="op">=</span>[x <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(N)]  <span class="co"># complesso simplicial astratto o euclideo</span></a>
<a class="sourceLine" id="cb9-3" title="3">B<span class="op">=</span>[ y <span class="cf">for</span> y <span class="kw">in</span>  <span class="bu">range</span>(N,N<span class="op">+</span>N)]  <span class="co"># (niente cooordinate o coordinate?)</span></a>
<a class="sourceLine" id="cb9-4" title="4">vertices <span class="op">=</span> A <span class="op">+</span> B <span class="co"># concatenation of lists (overloading degli operatori)</span></a>
<a class="sourceLine" id="cb9-5" title="5">edges <span class="op">=</span> [ [x, y] <span class="cf">for</span> x <span class="kw">in</span> A <span class="cf">for</span> y <span class="kw">in</span> B ] <span class="co"># math notation</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="bu">print</span>(vertices,edges)</a>
<a class="sourceLine" id="cb9-7" title="7">eucl_S<span class="op">=</span>euclidean_embedding(vertices,edges)</a>
<a class="sourceLine" id="cb9-8" title="8">view(eucl_S,show_labels<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [[0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [2, 5], [2, 6], [2, 7], [2, 8], [2, 9], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9]]
howsol: 1.4563980367849192e-05</code></pre>
<figure>
<img src="w2_files/w2_8_1.png" alt="png" /><figcaption>png</figcaption>
</figure>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1">N<span class="op">=</span><span class="dv">7</span></a>
<a class="sourceLine" id="cb11-2" title="2">vertices <span class="op">=</span> [ x <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(N)]</a>
<a class="sourceLine" id="cb11-3" title="3">edges <span class="op">=</span> [ <span class="bu">sorted</span>( [x, (x<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> N] ) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(N)] <span class="op">+</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb11-4" title="4"> [ <span class="bu">sorted</span>( [x,(x<span class="op">+</span><span class="dv">3</span>) <span class="op">%</span>N ]) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(N) ]</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="bu">print</span>(vertices,edges)</a>
<a class="sourceLine" id="cb11-6" title="6">eucl_S<span class="op">=</span>euclidean_embedding(vertices,edges)</a>
<a class="sourceLine" id="cb11-7" title="7">view(eucl_S,show_labels<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<pre><code>[0, 1, 2, 3, 4, 5, 6] [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [0, 6], [0, 3], [1, 4], [2, 5], [3, 6], [0, 4], [1, 5], [2, 6]]
howsol: 3.9716886522722156e-06</code></pre>
<figure>
<img src="w2_files/w2_9_1.png" alt="png" /><figcaption>png</figcaption>
</figure>
<h2 id="quindi-da-fare">Quindi da fare…</h2>
<blockquote>
<p>Provare a fare eseguire i pezzi sopra di codice (copia-e-incolla), modificandoli qua e là. Quale potenziale è meglio per rappresentare visualmente i grafi? Qualcosa in 3d? E se ciascuno riuscisse a portare su <em>e-learning</em> l’immagine di un grafo di cui si è calcolato l’omologia? Fare piccola una galleria?</p>
</blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"></code></pre></div>

</div>

     </div>
    </div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
<footer class="site-footer">
    <div class="container">
        <p class="powered-by">
            Copyright © 2016 - 3016, DL Ferrario &middot; 
	    <a href="//www.dlfer.xyz/p/privacy/">Privacy</a> &middot;
            Powered by <a href="http://gohugo.io" target="_blank">Hugo</a>.
            <span class="pull-right"><a href="#" id="back_to_top"><span class="button_icon"><i class="fa fa-chevron-up fa-2x" aria-hidden="true"></i></span></a></span>
        </p>
    </div>
</footer>
    
  
        
        
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ tex2jax: { 
                                          inlineMath: [['$','$'], ['\\(','\\)']], 
				          displayMath: [['$$','$$'], ['\\[','\\]']],
				          processEscapes: true,
				          processEnvironments: true,
				          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				          TeX: { equationNumbers: { autoNumber: "AMS" },
				          extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js"] }
                                           } 
                                });
        </script>
        <script async src="//www.dlfer.xyz//MJ/MathJax.js?config=TeX-AMS_CHTML,local/local.js"></script>
        
  
 
</body>
</html>


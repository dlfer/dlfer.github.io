<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DL Ferrario&#39;s Test Web Page </title>
    <link>http://www.dlfer.xyz/tags/examples/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2019</rights>
    <updated>2016-10-27 11:45:52 &#43;0200 CEST</updated>

    
      
        <item>
          <title>Computing the Smith Normal Form of a matrix, and homology groups?</title>
          <link>http://www.dlfer.xyz/post/2016-10-27-smith-normal-form/</link>
          <pubDate>Thu, 27 Oct 2016 11:45:52 CEST</pubDate>
          <author></author>
          <guid>http://www.dlfer.xyz/post/2016-10-27-smith-normal-form/</guid>
          <description>

&lt;h2 id=&#34;a-simple-algorithm-for-computing-the-smith-normal-form-of-a-matrix-in-zz:86e251d64fab5ccb414132090cd54af7&#34;&gt;A simple algorithm for computing the Smith Normal Form of a matrix in $\ZZ$&lt;/h2&gt;

&lt;p&gt;The proof and the algorithm are the same.&lt;/p&gt;

&lt;p&gt;First, a few auxiliary functions. Given a matrix $M$, the follow two functions are
self-explanatory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dims(M):
 num_righe=len(M)
 num_colonne=len(M[0])
 return (num_righe,num_colonne)

def MinAij(M,s):
 num_righe, num_colonne=dims(M)
 ijmin=[s,s]
 valmin=max( max([abs(x) for x in M[j][s:]]) for j in range(s,num_righe) )
 for i in (range(s,num_righe)):
  for j in (range(s,num_colonne)):
   if (M[i][j] != 0 ) and (abs(M[i][j]) &amp;lt;= valmin) :
    ijmin = [i,j]
    valmin = abs(M[i][j])
 return ijmin

def IdentityMatrix(n):
 res=[[0 for j in range(n)] for i in range(n)]
 for i in range(n):
  res[i][i] = 1
 return res

def display(M):
 r=&amp;quot;&amp;quot;
 for x in M:
  r += &amp;quot;%s\n&amp;quot; % x
 return r +&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, one needs the elementary operations on rows and columns on the matrix $M$:
swap (permute) two rows, add to a row an integer multiple of another row, and
change sign of a row. The same for columns.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def swap_rows(M,i,j):
 tmp=M[i]
 M[i]=M[j]
 M[j]=tmp

def swap_columns(M,i,j):
 num_of_columns=len(M)
 for x in range(num_of_columns):
  tmp=M[x][i]
  M[x][i] = M[x][j]
  M[x][j] = tmp

def add_to_row(M,x,k,s):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_colonne):
  M[x][tmpj] += k * M[s][tmpj]

def add_to_column(M,x,k,s):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_righe):
  M[tmpj][x] += k * M[tmpj][s]

def change_sign_row(M,x):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_colonne):
  M[x][tmpj] = - M[x][tmpj]

def change_sign_column(M,x):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_righe):
  M[tmpj][x] = - M[tmpj][x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, two important functions. The first,  checks that the entry at place $(s,s)$ in the matrix $M$
is the only one non-zero in its $s$-th column under $s$ and $s$-th row at the right of $s$. If this is true,
then the algorithm will proceed.&lt;/p&gt;

&lt;p&gt;The second, will scan in the submatrix at the lower-right of $M_ {s,s}$, to check if there is any entry which
is not divisible by $M_ {s,s}$. If it cannot be found, then it returns an empty set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def is_lone(M,s):
 num_righe,num_colonne=dims(M)
 if [M[s][x] for x in range(s+1,num_colonne) if M[s][x] != 0] + [ M[y][s] for y in range(s+1,num_righe) if M[y][s] != 0] == []:
  return True
 else:
  return False

def get_nextentry(M,s):
  # find and element which is not divisible by M[s][s]
  num_righe,num_colonne=dims(M)
  for x in range(s+1,num_righe):
   for y in range(s+1,num_colonne):
    if M[x][y] % M[s][s]  != 0:
     return (x,y)
  return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given all these functions, the algorithm/proof is rather simple, as written in the folliwing block.
The main idea is to put at the UL corner $M_ {0,0}$ the GCD of all matrix entries,
by row/column operations.&lt;/p&gt;

&lt;p&gt;First, find the smallest non-zero entry, and put it in the UL corner.
Then, as in the Euclidean Algorithm, sum to all rows and columns suitable multiples of the first
row/column.
After this, either
all the elements in the $0$-th row and $0$-th column are zero except $M_ {0,0}$, or not.
If all the elements in the $0$-th row and $0$-th column V
except $M_ {0,0}$  are zero,
then either $M_ {0,0}$ divides all the entries of $M$,
or not.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If it does divide all&lt;/strong&gt;,
then proceed to the submatrix obtained by deleting the first row and the first column.
It is important to note that since $M_ {0,0}$ divides all the entries of $M$,
it will divide all the entries of the submatrix and also all the entries of
the subsequente modifications of the submatrix. Hence, when at the end the matrix will be
in diagonal form, the first term $M_ {0,0}$ will divide all the others.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If it does not divide all&lt;/strong&gt;, then add to the first row the row containing the entry which is not
divisible by $M_ {0,0}$.
So, the new matrix is of the type with $M_ {0,0}$ at the UL corner, and
not all the elements in the $0$-th row and $0$-th column
except $M_ {0,0}$  are zero.&lt;/p&gt;

&lt;p&gt;Now go back  to the step of finding the new non-zero minimum, put it in $(0,0)$,  and repeat from there.&lt;/p&gt;

&lt;p&gt;Why in a finite number of steps $M_ {0,0}$ has to divide all the entries?
At the UL corner, $M_ {0,0}$ was chosen to be the minimum of non-zero terms
of $M$, and the new one will be $M&#39;_ {0,0} \leq M_ {0,0}$. But, if there was an entry&lt;br /&gt;
not divisible by $M_ {0,0}$, then $M&#39;_ {0,0} &amp;lt; M_ {0,0}$.
We show this with an example.
Assume $a$ does not divide $b$ (and hence $a\neq b$),
both positive. First, add the second row to the first.
$$
\begin{bmatrix}
a &amp;amp; 0 \\\
0 &amp;amp; b
\end{bmatrix}
\mapsto
\begin{bmatrix}
a &amp;amp; b \\\
0 &amp;amp; b
\end{bmatrix}
$$
Then, there are two cases: either $a &amp;lt; b$, and we do nothing,  or $a &amp;gt; b$,
and we permute the two columns.
$$
\mapsto
\begin{cases}
\begin{bmatrix}
a &amp;amp; b \\\
0 &amp;amp; b
\end{bmatrix}
&amp;amp; \text{if $a&amp;lt;b$}
\\\
\begin{bmatrix}
b &amp;amp; a \\\
b &amp;amp; 0
\end{bmatrix}
&amp;amp; \text{if $b &amp;lt; a$}
\end{cases}
$$
After this, it is time to add suitable multiples. In the two cases,
it happens (adding forst rows, then columns) the following.
$$
\mapsto
\begin{cases}
\begin{bmatrix}
a &amp;amp; b-qa \\\
0 &amp;amp; b
\end{bmatrix}
&amp;amp; \text{if $a&amp;lt;b$}
\\\
\begin{bmatrix}
b &amp;amp; a-qb \\\
0 &amp;amp; -a
\end{bmatrix}
&amp;amp; \text{if $b &amp;lt; a$}
\end{cases}
$$
If $a&amp;lt;b$, it is $|b-qa|&amp;lt;a$.
If $b&amp;lt;a$, it is $|a-qb| &amp;lt; b &amp;lt; a$.
Hence in both cases after the row/column operations, the minimum of the matrix entries
will be strictly smaller than $a$. Since this cannot happen indefinitively, after a finite
number of steps $M_ {0,0}$ will divide all the remaining entries in $M$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def Smith(M):
 num_righe,num_colonne=dims(M)
 L = IdentityMatrix(num_righe)
 R = IdentityMatrix(num_colonne)
 maxs=min(num_righe,num_colonne)
 for s in range(maxs):
  print (&amp;quot;step %s/%s\n&amp;quot; % (s+1,maxs))
  print &amp;quot;M:&amp;quot;, display(M)
  while not is_lone(M,s):
   i,j = MinAij(M,s) # the non-zero entry with min |.|
   swap_rows(M,s,i)
   swap_rows(L,s,i)
   swap_columns(M,s,j)
   swap_columns(R,s,j)
   for x in range(s+1,num_righe):
    if M[x][s] != 0:
     k = M[x][s] // M[s][s]
     add_to_row(M,x,-k,s)
     add_to_row(L,x,-k,s)
   for x in range(s+1,num_colonne):
    if M[s][x] != 0:
     k = M[s][x] // M[s][s]
     add_to_column(M,x,-k,s)
     add_to_column(R,x,-k,s)
   if is_lone(M,s):
    res=get_nextentry(M,s)
    if res:
     x,y=res
     add_to_row(M,s,1,x)
     add_to_row(L,s,1,x)
    else:
     if M[s][s]&amp;lt;0:
      change_sign_row(M,s)
      change_sign_row(L,s)
 return L,R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A minor step is the one for changing sign of the diagonal entry, just in the case it is negative. At the end, the matrix $M$ will be in
 Smith Normal Form,
and the routine will return the two unimodular matrices $L$ and $R$ resulting from the row/columns operations respectively.
They are obtained by applying the same row/column operations on two identity matrices.&lt;/p&gt;

&lt;h2 id=&#34;example-the-triangulated-sphere:86e251d64fab5ccb414132090cd54af7&#34;&gt;Example: the triangulated sphere.&lt;/h2&gt;

&lt;p&gt;As an example, here we compute the Smith Normal Forms of the differentials of che chain complex of the triangulate $2$-sphere,
from &lt;a href=&#34;http://www.sagemath.org&#34; target=&#34;_blank&#34;&gt;sage&lt;/a&gt;. First, the differential $\partial_ 1 \from C_ 1 \cong \ZZ^6 \to C_ 0 \cong \ZZ^4 $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: K=simplicial_complexes.Sphere(2)
sage: CK=K.chain_complex()
sage: 
sage: M=matrix(ZZ,CK.differential(1)).numpy().tolist()
sage: Smith(M)
step 1/4

M: [-1, -1, -1, 0, 0, 0]
[1, 0, 0, -1, -1, 0]
[0, 1, 0, 1, 0, -1]
[0, 0, 1, 0, 1, 1]

step 2/4

M: [1, 0, 0, 0, 0, 0]
[0, 0, 0, -1, -1, 1]
[0, 1, 1, 1, 1, 0]
[0, -1, -1, 0, 0, -1]

step 3/4

M: [1, 0, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[0, 0, 1, 1, 1, 1]
[0, 0, -1, -1, -1, -1]

step 4/4

M: [1, 0, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[0, 0, 1, 0, 0, 0]
[0, 0, 0, 0, 0, 0]

([[0, 0, 0, 1], [-1, 0, 0, 0], [-1, -1, 0, 0], [1, 1, 1, 1]],
 [[0, 1, -1, 1, 1, 0],
  [0, 0, 1, -1, -1, -1],
  [0, 0, 0, 0, 0, 1],
  [0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 1, 0],
  [1, 0, 0, 0, -1, -1]])
sage: print &amp;quot;\nsmith form of d_1:\n&amp;quot;, display(M)

smith form of d_1:
[1, 0, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[0, 0, 1, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hence $\operatorname{coker} \partial_ 1 \cong  \ZZ^1$ and $\ker \partial_ 1 \cong  \ZZ^3$.
What about the generators of $\ker \partial_ 1$?
Let $L$ and $R$ denote the left and right matrices, and $M$ the matrix of $\partial_ 1$.
Then let $S$ denote the Smith Normal Form of $\partial_ 1$, so that
$LMR = S$.
Since $\ker S$ is generated by the three vectors
$$
\begin{bmatrix}
0\\\
0\\\
0\\\
1\\\
0\\\
0
\end{bmatrix}
\begin{bmatrix}
0\\\
0\\\
0\\\
0\\\
1\\\
0
\end{bmatrix}
\begin{bmatrix}
0\\\
0\\\
0\\\
0\\\
0\\\
1
\end{bmatrix},
$$
then $\ker LM = \ker M$ is generated by their images by $R$, i.e.
the last three columns of $R$:
$$
\begin{bmatrix}
1\\\
-1\\\
0\\\
1\\\
0\\\
0
\end{bmatrix}
\begin{bmatrix}
1\\\
-1\\\
0\\\
0\\\
1\\\
-1
\end{bmatrix}
\begin{bmatrix}
0\\\
-1\\\
1\\\
0\\\
0\\\
-1
\end{bmatrix},
$$
These three cycles are, in the standard basis of $1$-simplices of $K$
$[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]$:
$$
[01]+[20]+[12] = [01] + [12] + [20]~,
$$
$$
[01]+[20]+[13]+[32] = [01] + [13] + [32] + [21]~,
$$
$$
[20] + [03] + [32]~.
$$&lt;/p&gt;

&lt;p&gt;Furthermore, about the differential $\partial_ 2$ from $C_ 2 \cong \ZZ^4 \to C_ 1 \cong \ZZ^6 $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: M=matrix(ZZ,CK.differential(2)).numpy().tolist()
sage: Smith(M)
step 1/4

M: [1, 1, 0, 0]
[-1, 0, 1, 0]
[0, -1, -1, 0]
[1, 0, 0, 1]
[0, 1, 0, -1]
[0, 0, 1, 1]

step 2/4

M: [1, 0, 0, 0]
[0, 0, 1, -1]
[0, -1, -1, 0]
[0, 0, -1, 1]
[0, 1, 1, 0]
[0, 1, 0, 1]

step 3/4

M: [1, 0, 0, 0]
[0, 1, 0, 0]
[0, 0, -1, -1]
[0, 0, -1, -1]
[0, 0, 1, 1]
[0, 0, 1, 1]

step 4/4

M: [1, 0, 0, 0]
[0, 1, 0, 0]
[0, 0, 1, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]

([[0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0],
  [1, 1, 0, 0, 0, 0],
  [0, 1, 0, 1, 0, -1],
  [-1, -1, 0, 0, 1, 1],
  [1, 1, 1, 0, 0, 0]],
 [[0, 1, -1, 1], [0, 0, 1, -1], [0, 0, 0, 1], [1, 0, 0, -1]])
sage: print &amp;quot;\nsmith form of d_2:\n&amp;quot;, display(M)

smith form of d_2:
[1, 0, 0, 0]
[0, 1, 0, 0]
[0, 0, 1, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Therefore, $\ker \partial_ 2 \cong \ZZ$, and $\operatorname{coker} \partial_ 2 \cong \ZZ^3$.
The generator of $\ker \partial_ 2$ is, as above, the last column of $R$,
which is
$$
\begin{bmatrix}
1\\\
-1\\\
1\\\
-1\\\
\end{bmatrix}
$$
which corresponds to the cycle
in the standard basis $ [ (0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3) ] $
$$
  [ 012 ] - [ 013 ] + [ 023 ] - [ 123 ] = - ( [ 123 ] - [ 023 ] + [ 013 ] - [ 012 ] ) =
$$
$$
= - \sum_ {j=0}^3 (-1)^j [ 0 \ldots \hat j \ldots 3 ]~.
$$&lt;/p&gt;

&lt;p&gt;Is it possible to compute the homology with these data?&lt;/p&gt;

&lt;h2 id=&#34;computing-homology-groups:86e251d64fab5ccb414132090cd54af7&#34;&gt;Computing homology groups&lt;/h2&gt;

&lt;p&gt;Now, consider just $H_ 1(K) = \ker \partial_ 1 / \operatorname{Im} \partial_ 2$.
Let $Z_ 1 = \ker \partial_ 1$ and $B_ 1 = \operatorname{Im} \partial_ 2$.
Let $S_ 1$ and $S_ 2$ the SNF&#39;s of $ \partial_ 1 $ and  $ \partial_ 2 $,
and $L_ 1$ , $L_ 2$, $R_ 1$ and $R_ 2$ the unimodular matrices of row/columns operations.
Then $L_ 1 \partial_ 1 R_ 1 = S_ 1$ and $L_ 2 \partial_ 2 R_ 2 = S_ 2$,
as in the following diagram.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;../../img/c2c1.svg&#34; alt=&#34;Chain complex diagram&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Let $\alpha_ 1$, $\alpha_ 2$, $\ldots$, $\alpha_ q$
be the &lt;em&gt;elementary divisors&lt;/em&gt; of $\partial_ 2$, i.e.
the non-zero diagonal terms of $S_ 2$,
and $\beta_ 1$, $\beta_ 2$, $\ldots$, $\beta_ r$
the &lt;em&gt;elementary divisors&lt;/em&gt; of $\partial_ 1$, i.e.
the non-zero diagonal terms of $S_ 1$.
Let $\ve_ 1$, $\ve_ 2$, $\ldots$, $\ve_ {c_ 1}$ be
the standard basis of $\ZZ^{c_ 1}$.&lt;/p&gt;

&lt;p&gt;Since $\ker S_ 1$ is generated by the
$c_ 1 - r$ elements $\ve_ {r+1}$, $\ldots$,
$\ve_ {c_ 1}$,
as show above, $Z_ 1$ is freely generated by the last $c_ 1 - r$ columns of $R_ 1$.&lt;/p&gt;

&lt;p&gt;On the other hand,
$\operatorname{Im} S_ 2$ is freely generated by
$$
\alpha_ 1 \ve_ 1, \alpha_ 2 \ve_ 2, \ldots, \alpha_ q \ve_ q
$$
hence
$B_ 1\subset Z_ 1 \subset C_ 1$ is freely generated by
$\alpha_ j$-multiples of the first $q$ columns of the inverse $L_ 2^{-1}$.
Now, $C_ 1 = Q \oplus Q&#39;$,
where $Q$ is the subgroup generated by the first $q$ columns of $L_ 2^{-1}$,
and $Q&#39;$ the subgroup generated by the last $c_ 1 - q$ columns of $L_ 2^{-1}$.&lt;/p&gt;

&lt;p&gt;By construction $B_ 1 \subset Q$, and since $C_ 1$ is torsion-free, $Q\subset Z_ 1$.
Now, define
 $Q&#39;&#39; = Q&#39; \cap Z_ 1$, which is a subgroup of $Z_ 1$.  Since $Q&#39;&#39; \cap Q = 0$,
it is defined the direct sum
$Q\oplus Q&#39;&#39; \subset Z_ 1$. If $x \in Z_ 1 \subset C_ 1 = Q \oplus Q&#39;$, then
$x=q + q&#39;$ with $q \in Q$ and $q&#39; \in Q&#39;$,
and $0 = \partial_ 1 x = \partial_ 1 q + \partial_ 1 q&#39; = \partial_ 1 q&#39;$,
hence $x=q + q&#39;$ with $q \in Q$ and $q&#39; \in Q&#39; \cap Z_ 1 = Q&#39;&#39;$,
and hence $Z_ 1 = Q \oplus Q&#39;&#39;$.&lt;/p&gt;

&lt;p&gt;Since $Z_ 1=Q\oplus Q&#39;&#39;$ is a free abelian group of rank $c_ 1 - r$,
and  $Q$ is a free abelian subgroup of rank $q$,&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;(1)&lt;/dt&gt;
&lt;dd&gt;$Q&#39;&#39;\subset Z_ 1$ is a free abelian group of rank $c_ 1 - r - q$.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Furthermore, since $B_ 1 \subset Q$,  the quotient $Z_ 1 / B_ 1$ splits as
$$
\dfrac{Z_ 1 }{ B_ 1  } =
\dfrac{Q \oplus  Q&#39;&#39;}{ B_ 1\oplus 0}
\cong
\dfrac{Q}{ B_ 1 } \oplus Q&#39;&#39;&lt;br /&gt;
 \cong
$$
$$
\cong \ZZ_ {\alpha_ 1} \oplus  \ldots \oplus
\ZZ_ {\alpha_ q} \oplus
\ZZ^{c_ 1 - r - q},
$$
where $\ZZ_ \alpha$ denotes the cyclic group
$\ZZ / \alpha \ZZ$ of order $\alpha$.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;(2)&lt;/dt&gt;
&lt;dd&gt;The homology group $H_ j$ is isomorphic to
$ \ZZ_ {\alpha_ 1} \oplus  \ldots \oplus
\ZZ_ {\alpha_ q} \oplus
\ZZ^{c_ j - r - q}$,
where $\alpha_ 1$, $\ldots,$ $\alpha_ q$ are the elementary divisors of $S_ {j+1}$,
$c_ j$ the rank of $C_ j$,
and $r$ the number of elementary divisors of $S_ j$.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;So, for the chain complex of the sphere:
$c_ 2 = 4$, $c_ 1 = 6$, $c_ 0 = 4$;
from $S_ 1$:
$\beta_ 1 = \beta_ 2 = \beta_ 3 = 1$,
$r= 3$;
from $S_ 2$:
$\alpha_ 1 = \alpha_ 2 = \alpha_ 3= 1$,
$q=3$.&lt;/p&gt;

&lt;p&gt;Hence, for the sphere,
$$
\begin{aligned}
H_ 0 &amp;amp;  \cong \ZZ_ 1 \oplus \ZZ_ 1 \oplus \ZZ_ 1 \oplus \ZZ^{4-0-3} = \ZZ \\\
H_ 1 &amp;amp; \cong \ZZ_ 1 \oplus \ZZ_ 1 \oplus \ZZ_ 1 \oplus \ZZ^{6-3-3} = 0 \\\
H_ 2 &amp;amp; \cong \ZZ^{4-0-3} = \ZZ .
\end{aligned}
$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; We did not compute explicit isomorphisms of $H_ j \cong Z_ j / B_ j$.
In fact, we even did not compute the inverse $L_ j^{-1}$. To have an explicit presentation
(generators  and relations) of $H_ j$ one needs to proceed as follows.&lt;/p&gt;

&lt;p&gt;First, generators of $\ker S_ 1$ in $\ZZ^{c_ 1}$ are $\ve_ {q+1}$, $\ldots,$ $\ve_ {c_ 1}$.
Next, generators of $R_ 1^{-1}Q$ are $\vw_ j = R_ 1^{-1} L_ 2^{-1} \ve_ j$ for $j=1,\ldots, q$.
Since for each $j=1,\ldots, q$, $L_ 2^{-1} \ve_ j \in Q$, hence
$$ S_ 1 \vw_ j = S_ 1 R_ 1^{-1} L_ 2^{-1} \ve_ j = L_ 1 \partial_ 1 L_ 2^{-1} \ve_ j = 0, $$
which means that the first $r$ entries of $\vw_ j$ are zero.
Note that the projection  $p\from Z_ 1 = Q\oplus Q&#39;&#39; \to Q $,
after $R_ 1^{-1}$, is a projection
$ \ZZ^{c_ 1 - r}  \to \ZZ^{q}$. Its kernel is $Q&#39;&#39;$.&lt;/p&gt;

&lt;p&gt;So, let $T$ denote the $(c_ 1 -r ) \times q$ matrix
whose $q$ columns are the last $c_ 1 - r$ entries of $\vw_ j$,
for $j=1,\ldots, q$. It represents the monomorphism
$T\from R_ 1^{-1} Q \to \ker S_ 1$, or
$T \from  \ZZ^q \to \ZZ^{c_ 1 - r}.$
Let $S_ T$ its Smith Normal Form, and $L_ T$ and $R_ T$ the unimodular matrices
such that $S_ T = L_ T T R_ T$.
By the arguments above, $S_ T $ has $q$ $1$&#39;s as elementary divisors,
and the rest are $0$.
Furthermore, the unimodular matrix
$L_ T ^{-1} \from \ZZ^{c_ 1 - r} \to \ZZ^{c_ 1 - r}$&lt;br /&gt;
sends the first $q$ elements of the standard basis $\ve_ j$, $j=1,\ldots, q$,
to a set of generators for $Q$ (the image of $T$ in $\ker S_ 1$).
The latter $c_ 1 - r - q$ columns of $L_ T^{-1}$ are the coefficients
of a set of generators of $Q&#39;&#39;$ in the standard basis of $\ker S_ 1$,
which we can denote by $\vw_ {q+1}, \ldots, \vw_ {c_ 1 - r}$ (by adding
$q$ zeros at the head of the $(c_ 1 - r)$-tuple).&lt;/p&gt;

&lt;p&gt;So, going back to $C_ 1$, $Z_ 1$ is generated by
the elements of $Q$, i.e.
$$ R_ 1 \vw_ 1 = L_ 2^{-1} \ve_ 1, \ldots R_ 1 \vw_ q = L_ 2^{-1} \ve_ q, $$
and the elements of  \( Q&#39;&#39; \),
i.e.&lt;br /&gt;
$$
R_ 1 \vw_ {q+1} =  R_ 1 L_ T^{-1} \ve_ {q+1} \ldots R_ 1 \vw_ {c_ 1 - r} =  R_ 1 L_ T^{-1} \ve_ {c_ 1 - r}
$$
where suitable zeros are added when necessary.
More in &lt;a href=&#34;http://link.springer.com/book/10.1007%2Fb97315&#34; target=&#34;_blank&#34;&gt;Computational Homology&lt;/a&gt;,
by &lt;em&gt;Tomasz Kaczynski, Konstantin Mischaikow, Marian Mrozek&lt;/em&gt;, Springer, 2004.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Császár torus, python and sagemath</title>
          <link>http://www.dlfer.xyz/post/2016-10-19-csaszar-torus/</link>
          <pubDate>Wed, 19 Oct 2016 13:55:55 CEST</pubDate>
          <author></author>
          <guid>http://www.dlfer.xyz/post/2016-10-19-csaszar-torus/</guid>
          <description>

&lt;h2 id=&#34;the-simplicial-complex:a0f7ea7056058d387334b524d50c28b9&#34;&gt;The simplicial complex&lt;/h2&gt;

&lt;p&gt;Consider the (abstract) simplicial  $T$ defined as follows:
vertices are
$$
X=\{ 0,1,2,3,4,5,6 \} = \{ j \mod 7 \}.
$$&lt;/p&gt;

&lt;p&gt;Now, for each $x\in X$ let $\Phi_ x$ denote the following subsets of $2^X$ :
$$
\begin{aligned}
H_ x &amp;amp;=
\{ \{j,j+1\}  : j =0 \ldots 6 \}
= \{ \{j,j-1\}  : j =0 \ldots 6 \}
\\\
V_ x &amp;amp;=
\{ \{ j,j+x \}  : j =0 \ldots 6 \}
= \{ \{ j,j-x \}  : j =0 \ldots 6 \}
\\\
D_ x &amp;amp;=
\{ \{ j, j + x+1 \} : j = 0 \ldots 6 \}
 = \{ \{ j, j - x-1 \} : j = 0 \ldots 6 \}
\\\
\Phi_ x &amp;amp; =
H_ x
\cup
V_ x
\cup
D_ x
\end{aligned}
$$
where all the integers $j$ are meant $\mod 7$.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;(1)&lt;/dt&gt;
&lt;dd&gt;The set $\Phi_ x$ has 21 elements (i.e., it is the set of all possible subsets of $X$ of cardinality $2$)
if and only if $x=2$ or $x=4$.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:
$\Phi_ x$ has 21 elements if and only if the three sets $H_ x$, $V_ x$ and $D_ x$ are disjoint.
Hence if they are disjoint then $x\neq 0$ (otherwise $D_ x =H_ x$),
$x\neq 1,6$ (otherwise $H_ x = V_ x$),
$x\neq 3$ (otherwise $\{0,3\} = \{ 3,7 \} \in V_ x \cap D_ x $),
and
$x\neq 5$ (otherwise $\{0,6\} = \{6,7 \} \in D_ x \cap H_ x$).
We are left with the cases
$x=2$ or $x=4$.
Lazy idea: write a few lines of python (2.7) and compute the number of elements
of $\Phi_ x$ for each $x$...&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def NumberOfPhi(x):
...  H= [ frozenset([j,(j+1) % 7 ]) for j in range(7) ]
...  V= [ frozenset([j,(j+x) % 7 ]) for j in range(7) ]
...  D = [ frozenset([j,(j+x+1) % 7 ]) for j in range(7) ]
...  return len( set(H) | set(V) | set(D) )
... 
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; [ NumberOfPhi(x) for x in range(7) ]
[14, 14, 21, 14, 21, 14, 14]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the end of the proof. &lt;em&gt;(/Proof)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, for $2$-simplexes we can proceed in a similar way. For each $x$,
let
$$ \begin{aligned}
L_ x  &amp;amp; = \{ \{ j,j+1,j+x+1 \} : j = 0 \ldots 6 \} \\\
U_ x  &amp;amp; = \{ \{ j, j+x, j+x+1 \} : j = 0 \ldots 6 \}.
\end{aligned}
$$
Hence
$$ \begin{aligned}
L_ 2  &amp;amp; = \{ \{ j,j+1,j+3 \} : j = 0 \ldots 6 \} \\\
U_ 2  &amp;amp; = \{ \{ j, j+2, j+3 \} : j = 0 \ldots 6 \} \\\
L_ 4  &amp;amp; = \{ \{ j,j+1,j+5 \} : j = 0 \ldots 6 \} \implies L_ 4 = U_ 2\\\
U_ 4  &amp;amp; = \{ \{ j, j+4, j+5 \} : j = 0 \ldots 6 \} \implies U_ 4 = L_ 2.
\end{aligned}
$$&lt;/p&gt;

&lt;p&gt;A little bit of typing and&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def Inter(x):
...  L = [ frozenset( [j,(j+1)%7, (j+x+1)%7 ]) for j in range(7) ]
...  U = [ frozenset( [j,(j+x)%7, (j+x+1)%7 ]) for j in range(7) ]
...  return len( set(L) | set(V) )
... 
&amp;gt;&amp;gt;&amp;gt; [ (x,Inter(x)) for x in range(7) ]
[(0, 14), (1, 14), (2, 14), (3, 14), (4, 14), (5, 14), (6, 14)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implies that for $x=2,4$ the following is an abstract simplicial complex:
$$
T = ( X, \{ L_ 2 \cup U_ 2 \cup \ldots \} )
 = ( X, \{ L_ 4 \cup U_ 4 \cup \ldots \} ),
$$
where the dots stand for all possible $1$-dimensional (i.e. 21) and $0$-dimensional (i.e. 7) simplexes.
The complex can be represented as in the following badly drawn diagram:
&lt;center&gt;
&lt;img src=&#34;../../img/toro.svg&#34; alt=&#34;Csaszar Torus&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;With a little bit of imagination and glueing, it is possible to &amp;quot;prove&amp;quot; the following proposition.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;(2)&lt;/dt&gt;
&lt;dd&gt;The abstract simplicial complex $T$ has the geometric realization which is homeomorphic to the torus $T^2 = S^1 \times S^1$.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:
It follows from the badly drawn diagram. The $2$-simplices $U_ 2$
are the upper diagonal triangles. The $2$-simplices
$L_ 2$ are the lower diagonal triangles.
The $21$ elements of $\Phi_ 2$ are all the edges (up to identification).&lt;br /&gt;
&lt;em&gt;(/Proof)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This complex is actually embeddable in $\RR^3$: on the &lt;a href=&#34;https://en.wikipedia.org/wiki/Cs%C3%A1sz%C3%A1r_polyhedron&#34; target=&#34;_blank&#34;&gt;Wikipedia page&lt;/a&gt;
one can find an embedding;
more details a the &lt;a href=&#34;http://www.eg-models.de/models/Classical_Models/2001.02.069/_preview.html&#34; target=&#34;_blank&#34;&gt;page in the Archive of Electronic Geometry Models&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;sagemath:a0f7ea7056058d387334b524d50c28b9&#34;&gt;SageMath&lt;/h2&gt;

&lt;p&gt;Here is a plain sage session. According to &lt;a href=&#34;http://doc.sagemath.org/html/en/reference/homology/sage/homology/examples.html&#34; target=&#34;_blank&#34;&gt;the documentation&lt;/a&gt;, the function &lt;code&gt;Torus&lt;/code&gt; returns Csaszar&#39;s Torus.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sage&#34;&gt;sage: T = simplicial_complexes.Torus();
sage: T.faces()
{-1: set([()]),
 0: set([(4,), (5,), (3,), (0,), (1,), (6,), (2,)]),
 1: set([(0, 6),
      (0, 5),
      (3, 6),
      (1, 2),
      (1, 5),
      (1, 6),
      (1, 3),
      (0, 3),
      (2, 6),
      (2, 4),
      (1, 4),
      (3, 5),
      (3, 4),
      (2, 3),
      (4, 6),
      (2, 5),
      (5, 6),
      (0, 2),
      (0, 1),
      (0, 4),
      (4, 5)]),
 2: set([(2, 4, 5),
      (0, 1, 5),
      (0, 4, 6),
      (1, 3, 6),
      (0, 3, 5),
      (1, 2, 4),
      (2, 3, 5),
      (1, 3, 4),
      (2, 3, 6),
      (0, 2, 6),
      (1, 5, 6),
      (0, 1, 2),
      (4, 5, 6),
      (0, 3, 4)])}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a little bit of reordering, faces of sage&#39;s $T$ are&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[(0, 1, 2),
 (0, 1, 5),
 (0, 2, 6),
 (0, 3, 4),
 (0, 3, 5),
 (0, 4, 6),
 (1, 2, 4),
 (1, 3, 4),
 (1, 3, 6),
 (1, 5, 6),
 (2, 3, 5),
 (2, 3, 6),
 (2, 4, 5),
 (4, 5, 6)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while faces in $U_ 2 \cup L_ 2$ are different.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[(0, 1, 3),
 (0, 1, 5),
 (0, 2, 3),
 (0, 2, 6),
 (0, 4, 5),
 (0, 4, 6),
 (1, 2, 4),
 (1, 2, 6),
 (1, 3, 4),
 (1, 5, 6),
 (2, 3, 5),
 (2, 4, 5),
 (3, 4, 6),
 (3, 5, 6)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It it just a permutation of indices, or they are distinct as simplicial complexes?
The automorphism group of $T$ has 42 elements&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: G=T.automorphism_group()
sage: len(G)
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and hence there are 120 = 7!/42 distinct possible classes of
 permutations. The easiest is $(0,6)$, which transforms one set of 2-faces into the other.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;(3)&lt;/dt&gt;
&lt;dd&gt;The two simplicial complexes are equivalent.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;A little bit of &lt;a href=&#34;http://www.sagemath.org&#34; target=&#34;_blank&#34;&gt;sagemath&lt;/a&gt; help in finding such permutations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;T = simplicial_complexes.Torus();

Facce= list(T.faces()[2])
Facce.sort()

def L(x):
 return set([ frozenset( [j,(j+1) % 7, (j+x+1) % 7 ]) for j in range(7) ] )
def U(x):
 return set([ frozenset( [j,(j+x) % 7, (j+x+1) % 7 ]) for j in range(7) ] )

myFacce=[tuple(a) for a in ( L(2) | U(2) ) ]
myFacce.sort()

G =SymmetricGroup((0,1,2,3,4,5,6))

def PermutedFacce(g,ListOfTuples):
 result=[]
 for t in ListOfTuples:
  goft=[g(x) for x in t ]
  goft.sort()
  result = result + [tuple(goft)]
 result.sort()
 return result

found=0
for g in G:
 pFacce=PermutedFacce(g,Facce)
 if pFacce == myFacce:
  found += 1
  print &amp;quot;found n. &amp;quot;, found, &amp;quot; : &amp;quot;, g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And interactively loading it (saved as &lt;code&gt;c.sage&lt;/code&gt;) gives the following session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: runfile (&amp;quot;c.sage&amp;quot;)
found n.  1  :  (2,5,3)(4,6)
found n.  2  :  (1,2,3,4,5,6)
found n.  3  :  (1,3,6,5,2)
found n.  4  :  (1,4,3)(2,6)
found n.  5  :  (1,5)(2,4)
found n.  6  :  (1,6,3,5,4)
found n.  7  :  (0,1)(2,3,6,4)
found n.  8  :  (0,1,2,6,5,4)
found n.  9  :  (0,1,3,5)(2,4,6)
found n.  10  :  (0,1,4,5,3)
found n.  11  :  (0,1,5,6,3,2)
found n.  12  :  (0,1,6)(2,5)(3,4)
found n.  13  :  (0,2,6,1)(3,5)
found n.  14  :  (0,2,4,3)(5,6)
found n.  15  :  (0,2)(1,3,4)
found n.  16  :  (0,2,5,1,4)(3,6)
found n.  17  :  (0,2,3,1,5,4,6)
found n.  18  :  (0,2,1,6,4,5)
found n.  19  :  (0,3,4,6,5,1)
found n.  20  :  (0,3,6,2)(4,5)
found n.  21  :  (0,3,1,2,5)
found n.  22  :  (0,3,5,6)(1,4,2)
found n.  23  :  (0,3)(1,5,2,6,4)
found n.  24  :  (0,3,2,4)(1,6)
found n.  25  :  (0,4,1)(2,5,6)
found n.  26  :  (0,4)(2,3,5)
found n.  27  :  (0,4,6,3)(1,2)
found n.  28  :  (0,4,5,1,3,2,6)
found n.  29  :  (0,4,3,6,1,5)
found n.  30  :  (0,4,2)(1,6,5,3)
found n.  31  :  (0,5,4,3,2,1)
found n.  32  :  (0,5)(2,6,3,4)
found n.  33  :  (0,5,3,6)(1,2,4)
found n.  34  :  (0,5,6,4)(1,3)
found n.  35  :  (0,5,2)(1,4,6)
found n.  36  :  (0,5,1,6,2,3)
found n.  37  :  (0,6,3,1)(2,4,5)
found n.  38  :  (0,6)
found n.  39  :  (0,6,4,3,5,1,2)
found n.  40  :  (0,6,1,3)(2,5,4)
found n.  41  :  (0,6,5)(1,4)(2,3)
found n.  42  :  (0,6,2,1,5,3,4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Equivalently, and shortly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: K=SimplicialComplex(myFacce)
sage: T=simplicial_complexes.Torus()
sage: T.is_isomorphic(K)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;embedding-the-complex-in-rr-3:a0f7ea7056058d387334b524d50c28b9&#34;&gt;Embedding the complex in $\RR^3$&lt;/h2&gt;

&lt;p&gt;The problem of embedding is not trivial. But ...&lt;/p&gt;

&lt;h2 id=&#34;poincaré-homology-3-sphere:a0f7ea7056058d387334b524d50c28b9&#34;&gt;Poincaré Homology 3-sphere&lt;/h2&gt;

&lt;p&gt;From &lt;a href=&#34;http://doc.sagemath.org/html/en/reference/homology/sage/homology/examples.html#sage.homology.examples.PoincareHomologyThreeSphere&#34; target=&#34;_blank&#34;&gt;sagemath documentation&lt;/a&gt;, and adding on...&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: Sigma3 = simplicial_complexes.PoincareHomologyThreeSphere()
sage: Sigma3.homology()
{0: 0, 1: 0, 2: 0, 3: Z}
sage: Sigma3.fundamental_group().cardinality()
sage: [len(Sigma3.faces()[x]) for x in range(4)]
[16, 106, 180, 90]
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>A counter-example for the exponentiation / adjoint of a function</title>
          <link>http://www.dlfer.xyz/post/counterexample-to-adjoint/</link>
          <pubDate>Wed, 05 Oct 2016 14:24:49 CEST</pubDate>
          <author></author>
          <guid>http://www.dlfer.xyz/post/counterexample-to-adjoint/</guid>
          <description>

&lt;h2 id=&#34;the-problem:cc5f1248a683bd633705733673dc5009&#34;&gt;The problem:&lt;/h2&gt;

&lt;p&gt;Let $X$, $Y$, and $Z$ be topological spaces. Let $Y^X$ denote the space
of all &lt;em&gt;continuous&lt;/em&gt; functions $X\to Y$, with the compact-open topology
generated by the
elements of the sub-basis $W_{K,U} = \{\varphi \in Y^X : \varphi K \subset U\}$,
where $K$ ranges over all compact subsets of $X$ and $U$
ranges over over all open subsets of $Y$.
Finite intersections of $W_{K,U}$ are a basis for the C.O. topology of $Y^X$.&lt;/p&gt;

&lt;p&gt;For each function $f\from  Z \times X  \to Y$ there is a function
$\hat f \from Z \to Y^X$
(the &lt;em&gt;adjoint&lt;/em&gt; of $f$)
defined as
$$
\hat f(z)(x) = f(z,x)
$$
for each $z \in X$ and each $x\in X$.
Conversely, for any function $\hat g \from Z \to Y^X$ there is a function
 $f\from Z \times X \to Y$ defined as $f(z,x) = \hat f (z)(x)$.&lt;/p&gt;

&lt;p&gt;If $f$ is  continuous, then its adjoint
$\hat f$ is continuous. But in general, $\hat f$ can be continuous
while the corresponding $f$ is not.
It turns out that if $Y$ is locally-compact Hausdorff, then the following proposition holds.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;&lt;a name=&#34;propo&#34;&gt;&lt;/a&gt; (1)&lt;/dt&gt;
&lt;dd&gt;If $Y$ is locally compact Hausdorff, then $f\from Z\times X \to Y$ is continuous
if and only if its adjoint $\hat f \from Z \to Y^X$ is continuous.&lt;br /&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;We give here a counter-example to proposition &lt;a href=&#34;#propo&#34;&gt;(1)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-rationals-qq:cc5f1248a683bd633705733673dc5009&#34;&gt;The  rationals $\QQ$:&lt;/h2&gt;

&lt;p&gt;Let $\QQ$ be the space rationals, with the standard euclidean metric topology. Then
the following proposition holds&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;&lt;a name=&#34;propo*&#34;&gt;&lt;/a&gt;(*)&lt;/dt&gt;
&lt;dd&gt;Let $K\subset \QQ$ be a compact subset, and $A\subset \QQ$ an open subset.
Then, there exists an open subset $V\subset \QQ$ such that
$K\subset V$ and there exists an element $a\in A$ such that $a\not\in V$.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:
First, note that $A\not\subset K$. If on the contrary $A\subset K$, then
there would be a sequence in $A$ converging to an irrational, and hence
a sequence in $K$ without converging subsequences in $K$.
So $A\not\subset K$ and
hence there exists $a \in A$ such that $a\not\in K$.
But then, it is easy to define an open subset $V$ containing $K$ but
not containing $a$. &lt;em&gt;(/Proof)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-sierpinski-space-mathbf-2:cc5f1248a683bd633705733673dc5009&#34;&gt;The Sierpinski Space $\mathbf{2}$:&lt;/h2&gt;

&lt;p&gt;Let $\mathbf{2}$ be the Sierpinski space.
That is, $\mathbf{2} = \{0,1\}$ with topology given by its (open) subsets $\{ \emptyset, \{1\}, \{0,1\} \}$.
The elements of
$\textbf{2}^\QQ$ are characteristic functions of the open
subsets of $\QQ$: a function $\varphi \from \QQ \to \textbf{2}$
is continuous if and only if $\varphi^{-1}(\{1\})$ is
open in $\QQ$, and hence if and only if $\varphi=\chi_A$ with
$A$ open in $\QQ$.&lt;/p&gt;

&lt;p&gt;The compact-open topology on $\textbf{2}^\QQ$ is generated by
the $W_{K,\{1\}}$, where
$K$ ranges over all the compact subsets of $\QQ$,
since the only non-trivial open subset of $\mathbf{2}$
is $\{1\}$. Being the union of a finite number of compact subsets
of $\QQ$ a compact subset of $\QQ$,
the set of $W_{K,\{1\}}$ is a basis (not just a sub-basis)
for the C.O. topology of $\mathbf{2}^\QQ$.
Also,
[
\varphi \in W_{K,\{1\}} \iff
\varphi^{-1}(1) \text{is an open subset containing $K$},
]
hence the elements of $W_{K,\{1\}}$ are
all the characteristic functions of those open subsets of
$\QQ$ which contain $K$.&lt;/p&gt;

&lt;h2 id=&#34;the-example:cc5f1248a683bd633705733673dc5009&#34;&gt;The example:&lt;/h2&gt;

&lt;p&gt;Let $X=\QQ$, $Y=\mathbf{2}$, and $Z=\mathbf{2}^\QQ$.
Then adjoint of the evaluation function
[
\epsilon \from \mathbf{2}^\QQ \times \QQ \to \mathbf{2}
]
(defined as $\epsilon(\varphi,q ) = \varphi(q)$ for each $q\in \QQ$
and each $\varphi \from \QQ \to \textbf{2}$)
is the identity map
[
\hat \epsilon = 1 \from \mathbf{2}^\QQ \to \mathbf{2}^\QQ,
]
since by definition $\hat \epsilon( \varphi ) (q) = \epsilon(\varphi,q) = \varphi(q)$
for each $q$.
Therefore&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;&lt;a name=&#34;propo2&#34;&gt;&lt;/a&gt;(2)&lt;/dt&gt;
&lt;dd&gt;The adjoint function $\hat \epsilon \from Z \to Y^X$ is continuous.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Now, since the only non-trivial open subset of $\mathbf{2}$ is $\{1\}$,&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;&lt;a name=&#34;propo3&#34;&gt;&lt;/a&gt;(3)&lt;/dt&gt;
&lt;dd&gt;The evaluation function $\epsilon \from \mathbf{2}^\QQ \times \QQ \to \mathbf{2}$
is continuous if and only if the subset
[
\{ (\varphi,q) \in \mathbf{2}^\QQ \times \QQ : \varphi(q) = 1 \}
]
is open on $\mathbf{2}^\QQ \times \QQ$.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Consider the element $\xi =  (\chi_\QQ,0) \in \mathbf{2}^\QQ \times \QQ$.
Since $\chi_\QQ(0) = 1$, $\xi \in \epsilon^{-1}( 1 ) $.&lt;/p&gt;

&lt;p&gt;Let $A\subset \QQ$ be any arbitrary open subset such that $0 \in A$;
let $K$ be an arbitrary compact subset of $\QQ$ (for which
$\chi_\QQ \in W_{K,\{1\}} \iff \chi_\QQ K = 1$,
and hence $\chi_\QQ \in W_{K,\{1\}}$).
Then
[
\xi \in W_{K,\{1\}} \times A~.
]
Now,
$ W_{K,\{1\}} \times A \subset \epsilon^{-1}(1) $
if and only if for &lt;strong&gt;each&lt;/strong&gt; open subset $V$ of $\QQ$ such that
$K\subset V$ and for &lt;strong&gt;each&lt;/strong&gt; $a \in A$ it happens that
[
\epsilon(\chi_V(a)) = \chi_V ( a ) = 1,
]
that is $a \in V$.
Hence, it is not true that
$ W_{K,\{1\}} \times A \subset \epsilon^{-1}(1) $
if and only if
there exists
an open subset $V$ of $\QQ$ such that
$K\subset V$ and an element $a \in A$ such that
$a \not\in V$.
By proposition &lt;a href=&#34;#propo*&#34;&gt;(*)&lt;/a&gt;, the conclusion follows.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;(E)&lt;/dt&gt;
&lt;dd&gt;The evaluation function $\epsilon$ is not continuous, while its adjoint $\hat\epsilon$ is continuous.&lt;/dd&gt;
&lt;/dl&gt;
</description>
        </item>
      
    

  </channel>
</rss>

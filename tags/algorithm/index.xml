<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DL Ferrario&#39;s Test Web Page </title>
    <link>http://blog.dlfer.xyz/tags/algorithm/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2016</rights>
    <updated>2016-10-27 11:45:52 &#43;0200 CEST</updated>

    
      
        <item>
          <title>Computing the Smith Normal Form of a matrix</title>
          <link>http://blog.dlfer.xyz/post/2016-10-27-smith-normal-form/</link>
          <pubDate>Thu, 27 Oct 2016 11:45:52 CEST</pubDate>
          <author></author>
          <guid>http://blog.dlfer.xyz/post/2016-10-27-smith-normal-form/</guid>
          <description>

&lt;h2 id=&#34;an-simple-algorithm-for-computing-the-smith-normal-form-of-a-matrix-in-zz&#34;&gt;An simple algorithm for computing the Smith Normal Form of a matrix in $\ZZ$&lt;/h2&gt;

&lt;p&gt;The proof and the algorithm are the same.&lt;/p&gt;

&lt;p&gt;First, a few auxiliary functions. Given a matrix $M$, the follow two functions are
self-explanatory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dims(M):
 num_righe=len(M)
 num_colonne=len(M[0])
 return (num_righe,num_colonne)

def MinAij(M,s):
 num_righe, num_colonne=dims(M)
 ijmin=[s,s]
 valmin=max( max([abs(x) for x in M[j][s:]]) for j in range(s,num_righe) )
 for i in (range(s,num_righe)):
  for j in (range(s,num_colonne)):
   if (M[i][j] != 0 ) and (abs(M[i][j]) &amp;lt;= valmin) :
    ijmin = [i,j]
    valmin = abs(M[i][j])
 return ijmin

def IdentityMatrix(n):
 res=[[0 for j in range(n)] for i in range(n)]
 for i in range(n):
  res[i][i] = 1
 return res

def display(M):
 r=&amp;quot;&amp;quot;
 for x in M:
  r += &amp;quot;%s\n&amp;quot; % x
 return r +&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, one needs the elementary operations on rows and columns on the matrix $M$:
swap (permute) two rows, add to a row an integer multiple of another row, and
change sign of a row. The same for columns.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def swap_rows(M,i,j):
 tmp=M[i]
 M[i]=M[j]
 M[j]=tmp

def swap_columns(M,i,j):
 num_of_columns=len(M)
 for x in range(num_of_columns):
  tmp=M[x][i]
  M[x][i] = M[x][j]
  M[x][j] = tmp

def add_to_row(M,x,k,s):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_colonne):
  M[x][tmpj] += k * M[s][tmpj]

def add_to_column(M,x,k,s):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_righe):
  M[tmpj][x] += k * M[tmpj][s]

def change_sign_row(M,x):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_colonne):
  M[x][tmpj] = - M[x][tmpj]

def change_sign_column(M,x):
 num_righe,num_colonne=dims(M)
 for tmpj in range(num_righe):
  M[tmpj][x] = - M[tmpj][x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, two important functions. The first,  checks that the entry at place $(s,s)$ in the matrix $M$
is the only one non-zero in its $s$-th column under $s$ and $s$-th row at the right of $s$. If this is true,
then the algorithm will proceed.&lt;/p&gt;

&lt;p&gt;The second, will scan in the submatrix at the lower-right of $M_ {s,s}$, to check if there is any entry which
is not divisible by $M_ {s,s}$. If it cannot be found, then it returns an empty set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def is_lone(M,s):
 num_righe,num_colonne=dims(M)
 if [M[s][x] for x in range(s+1,num_colonne) if M[s][x] != 0] + [ M[y][s] for y in range(s+1,num_righe) if M[y][s] != 0] == []:
  return True
 else:
  return False

def get_nextentry(M,s):
  # find and element which is not divisible by M[s][s]
  num_righe,num_colonne=dims(M)
  for x in range(s+1,num_righe):
   for y in range(s+1,num_colonne):
    if M[x][y] % M[s][s]  != 0:
     return (x,y)
  return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given all these functions, the algorithm/proof is rather simple, as written in the folliwing block.
The main idea is to put at the UL corner $M_ {0,0}$ the GCD of all matrix entries,
by row/column operations.&lt;/p&gt;

&lt;p&gt;First, find the smallest non-zero entry, and put it in the UL corner.
Then, as in the Euclidean Algorithm, sum to all rows and columns suitable multiples of the first
row/column.
After this, either
all the elements in the $0$-th row and $0$-th column are zero except $M_ {0,0}$, or not.
If all the elements in the $0$-th row and $0$-th column V
except $M_ {0,0}$  are zero,
then either $M_ {0,0}$ divides all the entries of $M$,
or not.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If it does divide all&lt;/strong&gt;,
then proceed to the submatrix obtained by deleting the first row and the first column.
It is important to note that since $M_ {0,0}$ divides all the entries of $M$,
it will divide all the entries of the submatrix and also all the entries of
the subsequente modifications of the submatrix. Hence, when at the end the matrix will be
in diagonal form, the first term $M_ {0,0}$ will divide all the others.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If it does not divide all&lt;/strong&gt;, then add to the first row the row containing the entry which is not
divisible by $M_ {0,0}$.
So, the new matrix is of the type with $M_ {0,0}$ at the UL corner, and
not all the elements in the $0$-th row and $0$-th column
except $M_ {0,0}$  are zero.&lt;/p&gt;

&lt;p&gt;Now go back  to the step of finding the new non-zero minimum, put it in $(0,0)$,  and repeat from there.&lt;/p&gt;

&lt;p&gt;Why in a finite number of steps $M_ {0,0}$ has to divide all the entries?
At the UL corner, $M_ {0,0}$ was chosen to be the minimum of non-zero terms
of $M$, and the new one will be $M&amp;rsquo;_ {0,0} \leq M_ {0,0}$. But, if there was an entry&lt;br /&gt;
not divisible by $M_ {0,0}$, then $M&amp;rsquo;_ {0,0} &amp;lt; M_ {0,0}$.
We show this with an example.
Assume $a$ does not divide $b$ (and hence $a\neq b$),
both positive. First, add the second row to the first.
$$
\begin{bmatrix}
a &amp;amp; 0 \\&lt;br /&gt;
0 &amp;amp; b
\end{bmatrix}
\mapsto
\begin{bmatrix}
a &amp;amp; b \\&lt;br /&gt;
0 &amp;amp; b
\end{bmatrix}
$$
Then, there are two cases: either $a &amp;lt; b$, and we do nothing,  or $a &amp;gt; b$,
and we permute the two columns.
$$
\mapsto
\begin{cases}
\begin{bmatrix}
a &amp;amp; b \\&lt;br /&gt;
0 &amp;amp; b
\end{bmatrix}
&amp;amp; \text{if $a&amp;lt;b$}
\\&lt;br /&gt;
\begin{bmatrix}
b &amp;amp; a \\&lt;br /&gt;
b &amp;amp; 0
\end{bmatrix}
&amp;amp; \text{if $b &amp;lt; a$}
\end{cases}
$$
After this, it is time to add suitable multiples. In the two cases,
it happens (adding forst rows, then columns) the following.
$$
\mapsto
\begin{cases}
\begin{bmatrix}
a &amp;amp; b-qa \\&lt;br /&gt;
0 &amp;amp; b
\end{bmatrix}
&amp;amp; \text{if $a&amp;lt;b$}
\\&lt;br /&gt;
\begin{bmatrix}
b &amp;amp; a-qb \\&lt;br /&gt;
0 &amp;amp; -a
\end{bmatrix}
&amp;amp; \text{if $b &amp;lt; a$}
\end{cases}
$$
If $a&amp;lt;b$, it is $|b-qa|&amp;lt;a$.
If $b&amp;lt;a$, it is $|a-qb| &amp;lt; b &amp;lt; a$.
Hence in both cases after the row/column operations, the minimum of the matrix entries
will be strictly smaller than $a$. Since this cannot happen indefinitively, after a finite
number of steps $M_ {0,0}$ will divide all the remaining entries in $M$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def Smith(M):
 num_righe,num_colonne=dims(M)
 L = IdentityMatrix(num_righe)
 R = IdentityMatrix(num_colonne)
 maxs=min(num_righe,num_colonne)
 for s in range(maxs):
  print (&amp;quot;step %s/%s\n&amp;quot; % (s+1,maxs))
  print &amp;quot;M:&amp;quot;, display(M)
  while not is_lone(M,s):
   i,j = MinAij(M,s) # the non-zero entry with min |.|
   swap_rows(M,s,i)
   swap_rows(L,s,i)
   swap_columns(M,s,j)
   swap_columns(R,s,j)
   for x in range(s+1,num_righe):
    if M[x][s] != 0:
     k = M[x][s] // M[s][s]
     add_to_row(M,x,-k,s)
     add_to_row(L,x,-k,s)
   for x in range(s+1,num_colonne):
    if M[s][x] != 0:
     k = M[s][x] // M[s][s]
     add_to_column(M,x,-k,s)
     add_to_column(R,x,-k,s)
   if is_lone(M,s):
    res=get_nextentry(M,s)
    if res:
     x,y=res
     add_to_row(M,s,1,x)
     add_to_row(L,s,1,x)
    else:
     if M[s][s]&amp;lt;0:
      change_sign_row(M,s)
      change_sign_row(L,s)
 return L,R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A minor step is the one for changing sign of the diagonal entry, just in the case it is negative. At the end, the matrix $M$ will be in
 Smith Normal Form,
and the routine will return the two unimodular matrices $L$ and $R$ resulting from the row/columns operations respectively.
They are obtained by applying the same row/column operations on two identity matrices.&lt;/p&gt;

&lt;h2 id=&#34;example-the-triangulated-sphere&#34;&gt;Example: the triangulated sphere.&lt;/h2&gt;

&lt;p&gt;As an example, here we compute the Smith Normal Forms of the differentials of che chain complex of the triangulate $2$-sphere,
from &lt;a href=&#34;http://www.sagemath.org&#34; target=&#34;_blank&#34;&gt;sage&lt;/a&gt;. First, the differential $\partial_ 1 \from C_ 1 \cong \ZZ^6 \to C_ 0 \cong \ZZ^4 $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: K=simplicial_complexes.Sphere(2)
sage: CK=K.chain_complex()
sage: 
sage: M=matrix(ZZ,CK.differential(1)).numpy().tolist()
sage: Smith(M)
step 1/4

M: [-1, -1, -1, 0, 0, 0]
[1, 0, 0, -1, -1, 0]
[0, 1, 0, 1, 0, -1]
[0, 0, 1, 0, 1, 1]

step 2/4

M: [1, 0, 0, 0, 0, 0]
[0, 0, 0, -1, -1, 1]
[0, 1, 1, 1, 1, 0]
[0, -1, -1, 0, 0, -1]

step 3/4

M: [1, 0, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[0, 0, 1, 1, 1, 1]
[0, 0, -1, -1, -1, -1]

step 4/4

M: [1, 0, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[0, 0, 1, 0, 0, 0]
[0, 0, 0, 0, 0, 0]

([[0, 0, 0, 1], [-1, 0, 0, 0], [-1, -1, 0, 0], [1, 1, 1, 1]],
 [[0, 1, -1, 1, 1, 0],
  [0, 0, 1, -1, -1, -1],
  [0, 0, 0, 0, 0, 1],
  [0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 1, 0],
  [1, 0, 0, 0, -1, -1]])
sage: print &amp;quot;\nsmith form of d_1:\n&amp;quot;, display(M)

smith form of d_1:
[1, 0, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[0, 0, 1, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hence $\operatorname{coker} \partial_ 1 \cong  \ZZ^1$ and $\ker \partial_ 1 \cong  \ZZ^3$.
What about the generators of $\ker \partial_ 1$?
Let $L$ and $R$ denote the left and right matrices, and $M$ the matrix of $\partial_ 1$.
Then let $S$ denote the Smith Normal Form of $\partial_ 1$, so that
$LMR = S$.
Since $\ker S$ is generated by the three vectors
$$
\begin{bmatrix}
0\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
1\\&lt;br /&gt;
0\\&lt;br /&gt;
0
\end{bmatrix}
\begin{bmatrix}
0\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
1\\&lt;br /&gt;
0
\end{bmatrix}
\begin{bmatrix}
0\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
1
\end{bmatrix},
$$
then $\ker LM = \ker M$ is generated by their images by $R$, i.e.
the last three columns of $R$:
$$
\begin{bmatrix}
1\\&lt;br /&gt;
-1\\&lt;br /&gt;
0\\&lt;br /&gt;
1\\&lt;br /&gt;
0\\&lt;br /&gt;
0
\end{bmatrix}
\begin{bmatrix}
1\\&lt;br /&gt;
-1\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
1\\&lt;br /&gt;
-1
\end{bmatrix}
\begin{bmatrix}
0\\&lt;br /&gt;
-1\\&lt;br /&gt;
1\\&lt;br /&gt;
0\\&lt;br /&gt;
0\\&lt;br /&gt;
-1
\end{bmatrix},
$$
These three cycles are, in the standard basis of $1$-simplices of $K$
$[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]$:
$$
[01]+[20]+[12] = [01] + [12] + [20]~,
$$
$$
[01]+[20]+[13]+[32] = [01] + [13] + [32] + [21]~,
$$
$$
[20] + [03] + [32]~.
$$&lt;/p&gt;

&lt;p&gt;Furthermore, about the differential $\partial_ 2$ from $C_ 2 \cong \ZZ^4 \to C_ 1 \cong \ZZ^6 $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sage: M=matrix(ZZ,CK.differential(2)).numpy().tolist()
sage: Smith(M)
step 1/4

M: [1, 1, 0, 0]
[-1, 0, 1, 0]
[0, -1, -1, 0]
[1, 0, 0, 1]
[0, 1, 0, -1]
[0, 0, 1, 1]

step 2/4

M: [1, 0, 0, 0]
[0, 0, 1, -1]
[0, -1, -1, 0]
[0, 0, -1, 1]
[0, 1, 1, 0]
[0, 1, 0, 1]

step 3/4

M: [1, 0, 0, 0]
[0, 1, 0, 0]
[0, 0, -1, -1]
[0, 0, -1, -1]
[0, 0, 1, 1]
[0, 0, 1, 1]

step 4/4

M: [1, 0, 0, 0]
[0, 1, 0, 0]
[0, 0, 1, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]

([[0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0],
  [1, 1, 0, 0, 0, 0],
  [0, 1, 0, 1, 0, -1],
  [-1, -1, 0, 0, 1, 1],
  [1, 1, 1, 0, 0, 0]],
 [[0, 1, -1, 1], [0, 0, 1, -1], [0, 0, 0, 1], [1, 0, 0, -1]])
sage: print &amp;quot;\nsmith form of d_2:\n&amp;quot;, display(M)

smith form of d_2:
[1, 0, 0, 0]
[0, 1, 0, 0]
[0, 0, 1, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Therefore, $\ker \partial_ 2 \cong \ZZ$, and $\operatorname{coker} \partial_ 2 \cong \ZZ^3$.
The generator of $\ker \partial_ 2$ is, as above, the last column of $R$,
which is
$$
\begin{bmatrix}
1\\&lt;br /&gt;
-1\\&lt;br /&gt;
1\\&lt;br /&gt;
-1\\&lt;br /&gt;
\end{bmatrix}
$$
which correspond to the cycle
in the standard base $ [ (0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3) ] $
$$
  [ 012 ] - [ 013 ] + [ 023 ] - [ 123 ] = - ( [ 123 ] - [ 023 ] + [ 013 ] - [ 012 ] ) =
$$
$$
= - \sum_ {j=0}^3 (-1)^j [ 0 \ldots \hat j \ldots 3 ]~.
$$&lt;/p&gt;

&lt;p&gt;Is it possible to compute the homology with these data?&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
